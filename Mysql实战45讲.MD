## mysql执行过程
### 连接器
连接数据库，连接器负责和客户端建立连接、获取权限。

### 查询缓存
执行查询语句的时候，会先到查询缓存看看，如果之前执行过，则直接返回结果。

## redo log
当有一条记录需要更新的时候，InnoDB引擎会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时InnoDB引擎会在适当的时候，将这个记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候来做。

如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录然后再更新，整个过程IO成本和查找成本都很高。

## 隔离级别
1. 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到
2. 读提交：一个事务提交之后，它做的变更才会被其他事务看到
3. 可重复读：一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
4. 串行化：对于同一行记录，写加写锁，读加读锁。当出现读写锁冲突的时候，后访问的事务必须要等前一个事务执行完成，才能继续执行。

## 事务隔离的实现
在mysql中，每条记录更新的时候都会同时记录一条回滚操作，通过回滚操作，都可以得到前一个状态的值。当事务提交的时候，回滚日志将会被删除。

## 为何不建议长事务
长事务提交之前，数据库所有的回滚记录都必须保留，这就会导致大量占用存储空间。

## 索引的常见模型

### 哈希表
哈希表示一种以key-value存储数据的结构，它的思路是使用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置上。可以参考HashMap的设计原理。

哈希表这种结构只适合做等值查询，做区间查询的话每次都要全表查询一遍。

### 有序数组
等值查询和区间查询的效率都很高，但是更新数据时比较麻烦，你往中间插入一个记录就必须要挪动后面所有的记录，成本很高。所以有序数组索引只适合于不经常修改的数据。

### 搜索树
二叉搜索树的特点是每个节点的左儿子小于父节点，父节点小于右儿子。

树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。

为了让查询尽量访问少的数据块，需要把树高度降低，所以我们不应该使用二叉树，而应该使用N叉树。


## InnoDB的索引模型
每一个索引在InnoDB里面对应一棵B+树。
索引分为主键索引和二级索引

### 主键索引
叶子节点存的是整行数据

### 普通索引
叶子节点存的是主键的值

### 基于主键索引和普通索引的查询有什么区别？
- 通过主键索引查询只需要搜索主键ID对应的这棵B+树
- 通过普通索引查询则需要先搜索普通索引树，得到主键ID的值，然后再通过ID索引树搜索一次，这个过程称为回表。

### 为何不建议使用UUID作为主键？
1. UUID是无序的，每次插入一条新纪录并不是追加操作，每次都可能涉及到挪动其他记录，影响插入性能。
2. UUID太长，而普通索引的叶子节点是主键，这就会导致普通索引叶子节点很长，占用空间变大。

所以，从插入性能和存储空间方面考量，自增主键往往是更合理的选择。

## 覆盖索引
覆盖索引又称为联合索引，可以减少回表操作，显著提升查询性能，是一种常见的优化手段。

## 最左前缀原则
假设name和age建立了联合索引，那么以下语句是否用到了索引？
1. where name like ‘张%’；（可以使用name索引）
2. where name = ‘张三’ and age = 10；（可以使用到联合索引）
3. where age = 10；（不符合最左前缀，无法使用索引)

建立了联合索引后无需再给name单独建索引了。

## 全局锁
对整个数据库实例加锁。
应用场景：做全库逻辑备份


## 表级锁
表锁一般是在数据库引擎不支持行锁的时候才会被用到。
