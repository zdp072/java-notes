# 编程规约
## 命名风格
1. 【强制】抽象类命名使用Abstract或Base开头;异常类命名使用Exception结尾;测试类 命名以它要测试的类的名称开始，以 Test 结尾。

2. 【强制】POJO类中布尔类型变量都不要加is前缀，否则部分框架解析会引起序列化错误。

3. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使 用单数形式，但是类名如果有复数含义，类名可以使用复数形式。

4. 【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。

5. 【参考】Service/DAO层方法命名规约
> 1) 获取单个对象的方法用get做前缀，如: getXxx()。
> 
> 2) 获取多个对象的方法用list做前缀，如: listXxx()。 
> 
> 3) 获取统计值的方法用count做前缀，如: countXxx()。
> 
> 4) 插入的方法用save/insert做前缀，如: saveXxx()。
> 
> 5) 删除的方法用remove/delete做前缀，如: deleteXxx()。
> 
> 6) 修改的方法用update做前缀，如: updateXxx()。

6. 【参考】领域模型命名规约
> 数据对象:xxxDO，xxx为数据表名。
>
> 数据传输对象:xxxDTO，xxx为业务领域相关的名称。
>
> 展示对象:xxxVO，xxx一般为网页名称。

## 常量定义
1. 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。 
> 正例:缓存相关常量放在类CacheConsts下;系统配置相关常量放在类 ConfigConsts下。


## 代码格式
1. 【强制】注释的双斜线与注释内容之间有且仅有一个空格。

2. 【推荐】单个方法的总行数不超过 80 行。
> 正例:代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰;共性逻辑抽取成为共性方法，便于复用和维护。

## OOP规约
1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析 成本，直接用类名来访问即可。

2. 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。REST接口只能增加参数，不能减少参数，返回值的内容也是只增不减。

3. 【强制】所有整型包装类对象之间值的比较，全部使用equals方法比较。

4. 【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。（参考Case1.java）

5. 【强制】定义数据对象DO类时，属性类型要与数据库字段类型相匹配。

6. 【强制】为了防止精度损失，禁止使用构造方法BigDecimal(double)的方式把 double值转化为BigDecimal对象。（参考Case2.java）

7. 【强制】所有的POJO类属性必须使用包装数据类型。RPC方法的返回值和参数必须使用包装数据类型。所有的局部变量使用基本数据类型。

8. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。

9. 【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。（参考Case3.java）

10. 【推荐】慎用Object的clone方法来拷贝对象。
> 说明:对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。

## 集合处理
1. 【强制】只要覆写equals，就必须覆写hashCode。因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。

2. 【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用
Iterator方式，如果并发操作，需要对Iterator对象加锁。（参考Case5.java）

3. 【推荐】集合初始化时，指定集合初始值大小。说明:HashMap使用HashMap(int initialCapacity)初始化。

4. 【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。
> 说明: keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap 中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了 entry中，效率更高。


## 并发处理
1. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程.
> 说明: 线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问 题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

2. 【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 
> 说明:Executors 返回的线程池对象的弊端如下:FixedThreadPool和SingleThreadPool: Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。CachedThreadPool:Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

3. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。（参考Case6.java）

4. 【强制】必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收。（参考Case7.java）

5. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。
> 说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。

6. 【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。（参考Case8.java）

## 控制语句
1. 【强制】在高并发场景中，避免使用“等于”判断作为中断或退出的条件。
> 说明: 如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。
> > 反例: 判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。

2. 【推荐】表达异常的分支时，少用if-else方式，超过3层的if-else的逻辑判断代码可以使用策略模式、状态模式等来实现。（参考Case10.java）

3. 【推荐】避免采用取反逻辑运算符。
> 正例:使用if (x < 628)来表达 x 小于 628。
> 
> 反例:使用if (!(x >= 628))来表达 x 小于 628。

## 注释规约
1. 【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/** */格式，不得使用// xxx 方式

## 其他
1. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。

# 异常日志
## 异常处理
1. 【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch的方式来处理，比如:NullPointerException，IndexOutOfBoundsException等等。

2. 【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。说明:对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。

3. 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

4. 【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。

5. 【强制】不要在finally块中使用return。
> 说明:try 块中的 return 语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。（参考Case11.java）

6. 【推荐】防止 NPE，是程序员的基本修养，注意NPE产生的场景:
> 1) 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。（参考Case12.java）
> 
> 2) 数据库的查询结果可能为null。
> 
> 3) 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。
> 
> 4) 远程调用返回对象时，一律要求进行空指针判断，防止NPE。
> 
> 5) 对于Session中获取的数据，建议进行NPE检查，避免空指针。 
> 
> 6) 级联调用obj.getA().getB().getC();一连串调用，易产生 NPE。
> 

7. 【推荐】定义时区分unchecked/checked异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。

## 日志规约
1. 【强制】对于trace/debug/info级别的日志输出，必须进行日志级别的开关判断。

2. 【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。
> 正例:logger.error(各类参数或者对象 toString() + "_" + e.getMessage(), e);

# 单元测试
1. 【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。

2. 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。 
> 说明: 只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑， 那是集成测试的领域。

3. 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。 
> 说明: 新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。

4. 【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。> B: Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
> 
> C: Correct，正确的输入，并得到预期的结果。
> 
> D: Design，与设计文档相结合，来编写单元测试。
> 
> E: Error，强制错误信息输入(如:非法数据、异常流程、业务允许外等)，并得到预期的结果。
 
# 安全规约
1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。
> 说明: 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改 他人的订单。

2. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。

# 数据库
## 建表规约
1.  表示是与否概念的字段必须以is_xxx的方式命名，数据类型是unsigned tinyint。
> 正例: 表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。

2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。

3. 【强制】表名不使用复数名词。
> 说明:表名应该仅仅表示表里面的实体内容，不应该表示实体数量。

4. 【强制】主键索引名为pk_字段名;唯一索引名为uk_字段名;普通索引名则为idx_字段名。

5. 【强制】小数类型为decimal，禁止使用float和double。
> 说明:在存储的时候，float和double都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数并分开存储。

6. 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。

7. 【强制】表必备三字段:id,create_time,update_time。
> 说明: 其中id为主键，类型为bigint unsigned、单表时自增、步长为1。create_time, update_time的类型均为datetime。

8. 【推荐】表的命名最好是遵循“业务名称_表的作用”。
正例:alipay_task / force_project / trade_config

9. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。
> 冗余字段应遵循:
> 
> 1) 不是频繁修改的字段。
> 
> 2) 不是 varchar 超长字段，更不能是 text 字段。
> 
> 3) 不是唯一索引的字段。 
> 
> 正例:商品类目名称使用频率高，字段长度短，名称基本一不变，可在相关联的表中冗余存储类目名 称，避免关联查询。

## 索引规约
1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 
> 说明:不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

2. 【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致;多表关联查询时，保证被关联的字段需要有索引。

3. 【推荐】利用覆盖索引来进行查询操作，避免回表。
> 说明:如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。 
> 
> 正例:能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain 的结果，extra列会出现:using index。

4. 【推荐】SQL 性能优化的目标:至少要达到range级别，要求是ref级别，如果可以是consts最好。
> 1) consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。 
> 
> 2) ref指的是使用普通的索引(normal index)。
> 
> 3) range对索引进行范围检索。
>
> 反例:explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。

5. 【推荐】建组合索引的时候，区分度最高的在最左边。
> 正例:如果 where a=? and b=? ，如果a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。 
> 
> 说明:存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如:where c>? and d=? 那么 即使c的区分度更高，也必须把d放在索引的最前列，即索引idx_d_c。

6. 【参考】创建索引时避免有如下极端误解:
> 1) 宁滥勿缺。认为一个查询就需要建一个索引。
> 
> 2) 宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。
> 
> 3) 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

## SQL语句
1. 【强制】不要使用count(列名)或count(常量)来替代count(*)
> 说明: count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。

2. 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。
> 正例:使用如下方式来避免 sum 的 NPE 问题:SELECT IFNULL(SUM(column), 0) FROM table;

3. 【强制】使用ISNULL()来判断是否为NULL值。 
> 说明: NULL与任何值的直接比较都为 NULL。
> 
> 1) NULL<>NULL 的返回结果是 NULL，而不是 false。 
> 
> 2) NULL=NULL 的返回结果是 NULL，而不是 true。 
> 
> 3) NULL<>1 的返回结果是 NULL，而不是 true。

4. 【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。

5. 【参考】TRUNCATE TABLE比DELETE速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。

## ORM映射
1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
> 
> 1)增加查询分析器解析成本。
> 
> 2)增减字段容易与 resultMap 配置不一致。
> 
> 3)无用字段增加网络 消耗，尤其是 text 类型的字段。

2. 【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。

3. 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。

4. 【强制】更新数据表记录时，必须同时更新记录对应的update_time字段值为当前时间。

5. 【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。
> 执行SQL时，不要更新无改动的字段，一是易出错;二是效率低;三是增加 binlog 存储。

6. 【参考】@Transactional事务不要滥用。事务会影响数据库的QPS

# 工程结构
## 应用分层
1. 【参考】分层领域模型规约:
>
> 1) DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
> 
> 2) DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。
> 
> 3) VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

2. xxx

## 二方库依赖
1. 【强制】定义GAV遵从以下规则:
> 1) GroupID 格式:com.{公司/BU }.业务线 [.子业务线]，最多4 级。说明:{公司/BU} 例如:alibaba/taobao/tmall/aliexpress 等 BU 一级;子业务线可选。正例:com.taobao.jstorm 或 com.alibaba.dubbo.register
> 
> 2) ArtifactID 格式:产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。正例:dubbo-client / fastjson-api / jstorm-tool 
> 
> 3) Version:详细规定参考下方。

2. 【强制】二方库版本号命名方式:主版本号.次版本号.修订号 
> 1)主版本号:产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。
> 
> 2) 次版本号:保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。 
> 
> 3) 修订号:保持完全兼容性，修复BUG、新增次要功能特性等。
说明:注意起始版本号必须为:1.0.0，而不是0.0.1，正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本:1.3.3，那么下一个合理的版本号:1.3.4或1.4.0或 2.0.0

3. 【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 
> 说明:依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本:${spring.version}，定义依赖的时候，引用该版本。


## 服务器
1. 【推荐】给JVM环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让JVM碰到OOM场景时输出dump信息。

2. 【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC后调整堆大小带来的压力。

# 设计规约
1. 【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。

2. 【推荐】系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。

3. 【推荐】系统设计时，注意对扩展开放，对修改闭合。

4. 【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。